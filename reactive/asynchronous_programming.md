# 비동기 프로그래밍

비동기 프로그래밍과 웹 프레임워크의 관계에 대해 알아보기전에 비동기 프로그래밍과 관련된 중요한 개념들인 Blocking I/O, Non-Blocking I/O, Parallelism(병렬성), Concurrency(동시성 or 병행성), Asynchronous Programming(비동기 프로그래밍)을 살펴보고 각 개념들이 대표하고 있는 문제 해결 방식이 풀고자 하는 문제가 무엇이며 해결 방식과 문제를 추상화하여 알아보자. 그 후 비동기 프로그래밍을 적용한 웹 프레임워크란 무엇인지, 어떤 면에서 이점이 있는지 알아보자.

## Synchronous, Asynchronous, Non-Blocking, Blocking

**Synchronous** 에서 Syn 은 together(함께)라는 의미이며 뒤에 chronous 는 time(시간)이라는 의미이다. 따라서 **함께 어떤 시간을 맞춘다** 라고 해석할 수 있으며 **Asynchronous** 는 그 반대인 **함께 시간을 맞추지 않는다** 라고 해석할 수 있다. 동기, 비동기를 이야기할때는 반드시 **2가지 이상**을 언급해야하며(무엇과 무엇이), 시간 개념이 있어야한다.

* 동기 : 어떤 시간을 맞춘다
* 비동기 : 어떤 시간을 안맞춘다

A 와 B가 시작시간 또는 종료시간이 일치하면 동기이다. 에를 들어 A 와 B 쓰레드가 동시에 작업을 시작하면 동기(ex. Java's `CycileBarrier`), 메소드 리턴시간(A)와 결과를 전달받는 시간(B)이 일치하면 동기이다. 그리고 A가 끝나는 시간과 B가 시작하는 시간이 같으면 동기이다. 예를 들어 자바의 `synchronized` 와 `BlockingQueue` 가 있다.

블록킹 / 넌블록킹은 동기 / 비동기와 관점이 다르다. 내가 직접 제어할 수 없는 대상을 상대하는 방법이다. "내가 제어하지 못하는 제3의 존재, 대상을 내가 어떤식으로 상대할 것인가" 이런 부분의 설명이 필요하다면 블록킹 / 넌 블록킹 이야기를 같이하면 된다. 따라서 대상이 다소 제한적이며 예를 들어 I/O, 멀티쓰레드 동기화를 이야기할 때 블록킹 / 넌블록킹을 이야기할 수 있다.

정리하자면, 어떤 메소드를 호출하여 무언가를 가져와야하는데 받아와야 하는 데이터의 소스 자체가 내가 통제하지 못하는 제3의 존재로 부터 input을 받는다, I/O가 일어난다, 이럴때 블록킹 / 넌블록킹을 이야기할 수 있다. 또는, 나 말고 다른 스레드가 존재해서 무엇인가 작업을 하다가 어느순간부터 그 스레드로 부터 결과를 확인 받거나 그 스레드가 종료하는 것을 확인하고 넘어가야 하는 상황, 이런 상황일때 블록킹 / 넌블록킹을 이야기하면 된다.

> Ref) [스프링캠프 2017 [Day1 A2] : Async & Spring](https://www.youtube.com/watch?v=HKlUvCv9hvA&t=1847s)


## Non-Blocking I/O, Blocking I/O

- **Blocking I/O** : 프로그램이 외부와 데이터를 주고받을 떄, 외부에서 데이터를 처리하는 동안 가만히 기다리는 것.
- **Non-Blocking I/O** : 프로그램이 외부와 데이터를 주고받을 떄, 외부에서 데이터를 처리하는 동안 다른 일을 하며 기다리는 것.

Non-Blocking I/O 같은 경우 외부에서 필요한 작업을 하는 동안 프로그램은 다른 일을 할 수 있다. 따라서 개발자의 역량에 따라 프로그램의 자원을 효율적으로 사용할 수 있다. 다만, 프로그램과 외부 작업 사이에 데이터를 주고 받기위한 약속이 필요하고 이를 위한 추가 구현을 해야한다 (Blocking I/O 같은 경우는 외부 작업의 결과를 받기전까지 멈추어서 기다리 때문에 그 자리에서 바로 받음). 

이 때 결과를 가져오는 방식에 따라 두 분류로 나뉠 수 있다.

1. 수동적으로 가져오는 방식 (Asynchronous I/O)
2. 주도적으로 받아오는 방식 (Non-Blokcing I/O)

이렇게 나누더라도 본질은 여진히 입출력 결과를 수행하는 과정동안 일하기를 멈추지 않고 가다린다는 점이다. 

## Parallelism, Concurrency

* **Parallelism** : 작업을 처리하는 일꾼을 물리적으로 **여러개 두어 같은 작업을 동시에** 수행하는 것을 의미, 일꾼이 여러개여야만 성립하는 개념.
* **Concurrency** : 일꾼이 **여러가지 일을 번갈아 가며** 수행하는 것을 뜻함. 일꾼의 수와는 상관없이 오로지 일꾼이 일하는 방식과 연관.

동시성과 병렬성을 같이 확보하면 시너지 효과를 낼 수 있지만, 둘 사이의 의존성은 전혀 없다. **동시성**은 <u>자원을 효율적으로 사용하는 것이 목적</u>이고 **병렬성**은 <u>많은 자원을 투자해서 일의 처리량을 늘리는 것이 목적</u>이다. 

마찬가지로 동시성과 Non-Blocking I/O를 같이 사용하면 시너지 효과를 낼 수 있지만 둘 사이의 의존성은 전혀 없다 (다만, 동시성을 확보한 많은 시스템에서 Non-Blocking I/O를 이용하여 직업의 효율을 높이는 방식이 일반적인 사용법). 

* 논블록킹 I/O : 외부 입출력과 프로그램 사이의 작업을 어떻게 할 것인가를 대표하는 개념
* 동시성 : 일꾼이 일하는 방식을 대표하는 개념

동시성을 확보한 프로그램이 논블록킹 I/O를 중요한 요소로 사용할 수도 있고, 사용하지 않을 수도 있다. 일꾼이 하나더라고 모든 작업에 똑같이 1초씩 작업을 진행하면 동시성을 확보했다고 할 수 있다. **풀고자 하는 문제에 따라 알맞은 추상적 개념을 재료로 삼아 조립할 뿐이다.**

병렬성과 동시성은 웹 프레임워크에서 중요한 요소라고 할 수 있는데 비동기 프로그래밍 방식을 사용하기 이전의 웹 프레임워크에서는 병렬성만으로 성능을 확보하였지만 **비동기 프로그래밍 방식을 통해 동시성을 확보하기 시작한 이후부터는 일꾼을 늘리는 방식을 넘어서 일꾼들을 더 효율적으로 사용하는 방식을 사용하기 시작했다.**

정리하자면, **동시성과 병렬성 둘 사이 의존성은 전혀 없으며 마찬가지로 Non-Blocking I/O 와 동시성 둘 사이 의존성도 전혀 없다.**

## Asynchronous Programming

비동기 프로그래밍이란? **실행한 코드의 결과를 기다리지않고 별도의 채널에 결과 처리를 맡긴 후 다음 작업을 바로 진행하는 방식의 프로그래밍**을 뜻한다. 코드 실행 결과가 다음 코드 들에서 직접 연관이 없는 경우 실행의 결과를 기다릴 이유가 없기 때문에 자원을 더 효율적으로 사용할 여지가 생긴다.

비동기 프로그래밍에서는 크게 2가지 방식(콜백, 언어에서 지원하는 방식)으로 결과를 처리한다.

### Callback
함수를 값처럼 넘기는 First-class function 을 지원하는 언어에서 자연스럽게 사용할 수 있는 기법. 비동기 프로그래밍 방식으로 진행할 코드를 실행할 때 실행하는 시점에 결과를 처리해 줄 함수를 일꾼에게 같이 넘기며 이꾼은 작업 후 실제 결과를 실행 시점에 받은 함수를 통해 처리한다. 

### 언어에서 지원하는 방식
비동기로 실행한 코드의 결과를 언어에서 지원하는 방식으로 되돌려 받아 처리하는 방식. 코드를 비동기로 실행할 때 해당 코드의 실제 결과가 아닌 언어에서 지정하는 방식으로 결과를 **즉시** 되돌려 받는다. 언어적 방식을 통해 즉시 되돌려 받는 결과로는 **Future**, **Promise** 같은 객체 형태, Python's **Coroutine**과 같은 언어의 문법을 이용하는 형태, Go's Goroutine, 결과를 주고받을 별도의 채널을 사용하는 형태 등이 있다. **즉시 되돌려 받은 결과를 이용하여 각 방식에 알맞게 추후에 비동기로 실행한 코드의 실제 결과를 꺼내어 사용하는 형태**이다.

- 객체형태
실행 흐름을 프로그램으로 구현하여 마음껏 다룰 수 있기 때문에 높은 자유도가 있지만, 이를 위한 코드를 더 구현해야한다. 

- 언어의 문법을 이용한 형태
언어가 제공하는 제어문을 통해 비동기 프로그래밍의 실행 흐름을 언어의 실행 흐름으로 가져와 코드를 작성할 수 있지만 비동기 실행을 언어의 특정문법에 제한된다.

### Asynchronous Wait

비동기 프로그래밍으로 실행했던 작업의 결과를 다시 최초의 실행 흐름으로 되가져와 사용해야 하는 경우, Asynchronous Wait 는 기존의 실행 흐름에서 필요한 결과를 비동기 프로그래밍으로 실행한 작업에서 만들어낼 때까지 기다려 **두 작업간의 타이밍을 맞추는 역할**을 한다. 비동기 프로그래밍으로 실행한 작업과 원래 실행 흐름을 묶어주는 중요한 기법이다. 특히 절차 중심의 언어에서는 Asynchronous Wait 를 이용하여 실행 흐름을 제어하는 것은 자연스러운 방식이다. 

Asynchronous Wait 는 비동기 프로그래밍에서 중요한 핵심 요소이지만 몇 가지 단점이 있다.

1. Deadlock(교착 상태) 문제가 발생할 여지
2. **추상화의 수준을 절차 중심 프로그래밍 언어의 수준으로 낮추는 주된 요인**이며 이로 인해 실행 흐름 제어의 늪에 빠지게 될 수 있음
3. 비동기 프로그래밍의 기능을 절차 중심 프로그래밍이 가지는 추상화 수준에 맞추어 사용할 수 밖에 없게되는 문제
4. 사용자의 역량에 따라 자원을 효율적으로 사용할 수 있는 여지가 크게 달라짐

비동기 프로그래밍의 **추상화 수준을 높이는 계산 모델 또는 프로그래밍 모델을 사용**하면 실행 흐름을 직접 제어하는 일(절차 중심 프로그래밍 관점)에서 벗어날 수 있으며 deadlock 에 빠질 상황을 피할 수 있다. 

* Haskell, Scala, OCaml (함수 중심 프로그래밍 언어): 비동기 프로그래밍의 흐름 제어를 모나드(Monad)를 이용하여 함수를 엮어가는 방식으로 추상화 수준을 높여 사용.
* Reactive Programming : 프로그래밍의 관점을 절차 중심이 아니라 데이터의 흐름으로 바꾸어 실행 흐름을 데이터 흐름에 맞추어 따라가도록 하는 방식으로 추상화 수준을 높여 사용.

---

비동기 프로그래밍은 동시성, Non-Blocking I/O 와 매우 흡사해보이지만 **독립된 정의로 다루어야 한다**. 비동기 프로그래밍은 **"결과를 기다리지 않고 다음 코드를 실행하는 흐름"** 을 대표하는 개념이다. 이를 구현하기 위해 여러 일꾼을 사용하든 일꾼 하나에 작업 순서를 조절하여 사용하든 어떻게 구현할 지는 비동기 프로그래밍과 연관이 있을 수도 있지만 정의의 구성 요소라고 볼 수 없다. 

예를 들어 Event Loop 를 사용하여 병렬성을 확보하지 않고 오직 동시성만으로 비동기 프로그래밍을 제공하는 방식이 있으며 Callback 방식을 사용하여 동시성 없이 비동기 프로그래밍을 제공할 수도 있다. 이들은 **비동기 프로그래밍의 코드 진행을 구현하는 구현 방식들 중 하나일뿐 비동기 프로그래밍이 병렬성, 동시성, Non-Blocking I/O 에 종속된 개념은 아니다**.

## Asynchronous Programming and Web Framework

웹 프레임워크에서 비동기 프로그래밍은 **요청을 받아 이를 처리할 로직을 호출할 때 비동기 프로그래밍 방식을 사용하는 것**을 뜻한다. 웹 프레임워크의 핵심 기능은 요청과 처리 로직을 연결해 주는 것인데 웹 프레임워크에 비동기 프로그래밍 방식을 적용하였다는 것은 **요청과 처리 로직을 연결하는 과정에서 비동기 프로그래밍 방식을 사용한다는 것**을 뜻한다. 요청을 처리 로직에 맡겨두고 나서 결과를 별도의 채널을 통해 다루도록 넘긴 후 다른 처리를 해야 할 요청으로 넘어가는 일을 반복한다.

비동기 프로그래밍의 추상적인 실행 흐름을 실제로 수행해 줄 구현체로 **동시성**을 확보 한 구현체를 사용하면 2가지 관점에서 자원을 효율적으로 사용할 수 있다.

1. 동시성을 확보하는 것 자체로 자원을 효율적으로 사용할 여지가 있음

동시성과 시너지 효과를 내거나 동시성을 구현하기 위해 병렬성과 Non-Blocking I/O를 같이 사용한다면, 이 구현체를 사용하는 것만으로도 자원을 효율적으로 사용할 수 있다.


2. 요청과 처리 로직을 연결해주는 일과 처리 로직의 일을 분리하여 자원을 효율적으로 사용할 수 있음

`요청을 처리 로직과 연결해주는 일에 드는 자원` < `처리 로직에서 사용하는 자원` 이다. 또한 처리 로직에서 외부 요인으로 많은 시간을 기다려야 하는 경우도 있다. 처리 로직과 이를 연결해주는 일을 비동기 프로그래밍을 통해 분리해 버리면 자원을 필요한 곳에 필요한 만큼 사용할 수 있는 여지가 생기기 때문에 자원을 효츌적으로 사용할 수 있게 된다.

---

비동기 프로그래밍을 사용하지 않는 웹 프레임워크의 경우, 요청을 받아 처리를 한 후 결과를 되돌려 주는 작업을 하나의 일꾼이 수행하는데 요청수가 많아지면 물리적으로 제약이 생긴다. 반면에 비동기 프로그래밍을 사용하는 프레임워크는 물리적 제한을 따르지 않도록 할 수 있다. 

### Thread Pool

웹 프레임워크에서 지원하는 비동기 프로그래밍은 대부분 언어를 따라 스레드풀을 구현체로 사용한다. 즉, **동시성과 병렬성을 확보하여 작업을 효율적으로 수행**하기 위한 기법이다. 

> 대부분의 언어는 비동기 프로그래밍을 제공하기 위해 구현체로 스레드 풀을 많이 사용함

> **Thread Pool** 이란? <br>
> 일꾼의 단위를 스레드로 두고 미리 만들어둔 스레드를 풀에서 필요할 때 하나씩 꺼내어 사용하고 일이 끝나면 다시 풀에 넣어 다른 일에 사용할 수 있는 상태로 두는 방식

스래드가 일을 진행하다가 비동기로 실행해야 할 코드를 만나면 스레드 풀에서 스레드 하나를 가져와 비동기로 진행할 일을 맡기고 기존에 일을 하던 스레드는 비동기 실행에 관여하지않고 나머지 일을 마저 진행하는 방식이다. 비동기로 진행할 일을 맡은 스레드는 일이 끝나면 결과를 약속에 맞게 (Callback, 언어에서 지원하는 방식(Future, Promise 등) 처리하고 다시 스레드 풀로 돌아간다.

하지만 스레드가 고갈되지 않도록 신경 써야한다. 오래 걸리는 작업이 많아지는 경우, 이 작업을 수행하기 위해 스레드를 계속해서 투입 하다 보면 스레드 풀에 남아있는 스레드가 고갈될 수 있다. 이 문제를 해결하기 위해 2가지가 있다. 하나는 오래 걸리는 작업을 위한 별도의 스레드 풀을 사용하는 방식이고, 다른 하나는 비동기 작업 내부에 일어나는 I/O를 Non-Blocking I/O로 처리하는 것이다.

만약 Blocking I/O로 처리 할 경우, 입출력 결과를 기다리는 동안 스레드를 점유하고 있어야하므로 스레드가 고갈될 가능성이 생긴다. Non-Blocking I/O을 사용하면 일꾼은 스레드풀로 다시 돌아가 다른 일을 할 수 있어 자원을 효율적으로 사용할 수 있게 된다. 하지만 앞에서 말한 결과를 되돌려 받기 위해 약속을 정하고 이를 위한 추가 구현이 필요하다는 단점이 있다.

처리 로직에서 요청을 처리하다보면 다양항 입출력(DB, 다른 API Server, File system  등)을 사용하게 되는데 요청을 비동기 프로그래밍 방식으로 처리한다면 되도록이면 처리 도중 발생하는 입출력 작업은 Non-Blocking I/O로 입출력을 다루는 것이 좋다. 

결과 처리 로직의 구현이 복잡해지기 쉬운데 이를 극복하기 위해 더 높은 추상화 프로그래밍 모델을 사용하기도 한다.

## Higher abstraction level's Programming model amd Calculation model

비동기 프로그래밍을 필두로 다양한 프로그래밍 모델, 계산 모델을 도입하여 웹 프레임워크의 추상화 수준을 높여나가고 있다. 하지만 오랜 기간동안 많이 사용하고 있는 절차 중심(Imperative), 객체 지향(Object-Oriented) 프로그래밍은 추상화 수준을 높이는데 한계가 있다.

1. 절차 중심 프로그래밍

비동기 프로그래밍 같이 실행 흐름을 복잡하게 제어하거나, 여러 일꾼을 통해 일을 동시에 처리하는 방식의 계산에는 적합하지 않다. 또한 비동기 프로그래밍을 절차 중심 프로그래밍 관점으로 사용하는 경우 사용자의 역량에 따라 자원을 사용하는 효율이 달라진다.

2. 객체 지향 프로그래밍

마찬가지로, 객체의 상태와 맥락이 객체의 값을 결정하기 때문에, 실행 흐름이 복잡해 지는 경우 객체가 가진 값을 유추하기 어렵다.

---

위의 두 방식의 프로그래밍으로는 비동기 프로그래밍을 직관적이고 효율적으로 동작하도록 구현하려면 많은 노력이 필요하다.

옛날부터 병렬성 및 동시성을 높은 수준의 추상화로 다룰 수 있도록하는 프로그래밍 모델 또는 계산 모델을 연구해 왔다. 대표적으로,

- 파이 계산법(calculus)
- Actor Model
- Reative Programming

등이 있다. 파이 계산법은 람다 계산법과 대등한 층위에 있는 계산 모델로 여러 일꾼들이 일을 진행하고 데이터를 주고받는 작업들에 대해 엄밀하게 정의한 계산 모델이다. 이를 사용하기 좋게 재가공한 조인 계산법(join-calculus)이 있으며, 파이 계산법과 매우 유사한 형태의 언어인 Erlang 역시 이를 위한 계산 모델 위에서 프로그램을 실행한다. 

병렬성과 동시성을 계산하기 위한 계산 모델에 기반한 웹 프레임워크로는 Play Framework(Actor Model의 구현체인 Akka를 이용), Chicago Boss(Erlang) 등이 있다. Reactive Programming 은 웹 프레임워크는 아니지만 Netflix에서 도입하였으며, 스레드 안정성 및 데이터 동기화에 대한 걱정없이 서버의 동시성을 높이는데 효과적이다고 말한다.

비동기 프로그래밍의 흐름을 손쉽게 다루는데 값 중심 프로그래밍 (Value-Orient Programming), 함수형 프로그래밍 (Functional Programming)이 중요한 역할을 한다. 이들을 이용하여 비동기 프로그래밍의 흐름을 다루면, 실행 흐름의 복잡한 노리를 함수를 조립하는 방식을 통해 절차 중심(or 객체 중심)보다 직관적으로 구현이 가능한데 함수형 프로그래밍 같은 경우 프로그램을 실행 흐름 관점이 아닌 함수 관점으로 추상화해 나가는 방식이기 때문이다. 또한 타입 시스템과 타입 시스템이 제공하는 모나드(Monad)를 활용하여 실행흐름을 손쉽게 다룰 수 있다. **즉, 비동기 프로그래밍을 오로지 함수들의 조합과 타입 시스템을 통해 표현이 가능하다**. 

### Reactive Programming

Reactive Programming은 많은 자원을 효율적으로 사용하는 웹 프레임워크의 진화에 있어 가장 중요하고 영향력있는 역할이다. 많은 웹 프레임워크가 비동기 프로그래밍을 도입하듯이 앞으로 리엑티브 프로그래밍을 도입할 것 같다. 이미 Play Framework, Spring Framework에서는 리엑티브 프로그래밍을 도입하고 있다. 

* 비동기 프로그래밍 : 실행 결과를 가져오는 시점을 실행흐름으로부터 분리해 내는 작업
* 리액티브 프로그래밍 : 비동기 프로그래밍에서 하나씩 다루던 것을 한 번에 여러 개 씩 다룰수 있도록, **프로그래밍 관점을 실행흐름에서 데이터 흐름으로 옮기는 작업**

리액티브 프로그래밍에서 모든 데이터는 절차와 논리, 로직을 통해 옮겨 다니는 것이 아니라, 데이터 흐름을 통해서만 옮겨 다닌다. 데이터를 생성하면 생성한 데이터는 데이터의 흐름을 만들거나 데이터의 흐름에 들어가게 되고, 데이터의 흐름을 구독하여 데이터를 사용할 수 있다. 데이터를 만들고 사용하는 일련의 과정을 데이터의 흐름이라는 개념으로 나누어 분리했기 때문에 **각 작업은 비동기 방식으로 수행하면서 동시에 서로의 실행 흐름에 관여할 필요가 전혀 없다**.

데이터의 흐름을 기준으로 작업들을 나누어 수행하는 것이 가능하여 프로그래밍의 관점을 데이터 흐름으로 옮겨 비동기 프로그래밍과 이벤트 기반 프로그래밍(Event-Base Programming)들을 쉽게 조립하여 사용할 수 있다. 기존의 프로그래밍 주 관심사가 프로그램 실행 흐름이었다면 리액티브 프로그래밍은 실행 흐름이 아니라 데이터 흐름들을 어떻게 조작 하느냐이다. 

리엑티브 프로그래밍은 비동기 프로그래밍을 재료로 취급할 수 있도록 높은 추상화 수준을 제공하여 사용자에게는 이를 노출하지 않고 자연스럽게 사용할 수 있도록하는 기법이라고도 할 수 있다. 


## Reference

- [멈추지 않고 기다리기 (Non-blocking)와 비동기(Asynchronous) 그리고 동시성(Concurrency)
](https://tech.peoplefund.co.kr/2017/08/02/non-blocking-asynchronous-concurrency.html)

- [비동기 프로그래밍과 웹 프레임워크](https://kstreee.github.io/techmemo/async_and_webframework.pdf)

- [스프링캠프 2017 [Day1 A2] : Async & Spring](https://www.youtube.com/watch?v=HKlUvCv9hvA&t=1847s)
