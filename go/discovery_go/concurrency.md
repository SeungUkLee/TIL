# Concurrency (동시성)

동시성에 대한 개념을 알아보고 동시성을 이용하면 좋은 경우와 패턴들에 알아보자.

-----

## 고루틴

고루틴은 가벼운 스레드와 같은 것. 현재 수행 흐름과 **별개의 흐름** 을 만든다. OS 쓰레드보다 훨씬 가볍게 비동기 concurrent 처리를 구현하기 위하여 만든 것이다.

고루틴을 생성하는 방법은 아주 간단하다. 우선 함수를 어떻게 호출하였는지 생각해보자.

~~~ go
f(x, y, z)
~~~

이렇게 호출하여 현재 수행되는 흐름이 저 함수를 따라가 수행이 종료되고 돌아온다. 따라서 `f` 함수가 종료될 때까지 현재 함수는 수행 되지 않을 것이다.

~~~ go
go f(x, y, z)
~~~

위 코드와 같이 `go` 키워드를 붙여 함수를 호출하게 되면 `f(x, y, z)` 호출과 현재 함수의 흐름은 메모리를 공유하는 **논리적으로 별개의 흐름** 이 된다. (**물리적으로 별개의 흐름** 이 되는 것과는 구분된다.)


`go` 키워드를 사용하여 함수를 호출하면 런타임시 새로운 고루틴을 실행하며 고루틴은 asynchronously (비동기)로 함수루틴을 실행하여 여러 코드를 concurrently (동시적) 하게 실행하는데 사용된다. 


고루틴은 기본적으로 Go 런타임이 관리한다. Go 런타임 상에서 관리되는 작업단위인 여러 고루틴들은 종종 하나의 OS 쓰레드로 실행된다. 즉, 고루틴들은 OS 쓰레드와 1:1 로 대응되지 않고, Multiplexing (멀티플렉싱) 으로 훨씬 적은 OS 쓰레드를 사용한다. 메모리 측면에서도 고루틴이 훨씬 작은 스택을 갖는다. Go 런타임은 고루틴을 관리하면서 Go 채널을 통해 고루틴 간의 통신을 쉽게 할 수 있도록 한다.

### Parallelism (병렬성) 과 Concurrency (동시성)

위에서 말한 **물리적으로 별개의 흐름** 이란 정말 동시에 각가의 흐름이 수행되는 경우를 뜻하는 것이다. 즉 두 사람이 동시에 각각 업무를 보고 있다면 물리적으로 별개로 업무를 하는 것이다. 이것을 **Parallelism (병렬성)** 이라고 한다.


**논리적으로 별개의 흐름** 이란 예를 들어 커피를 마시면서 신문을 보고 있는 사람. 즉 두 흐름이 동시에 수행되는 것이 아니며 물리적으로 두 흐름이 있지 않지만 동시에 두가지 일을 하고 있는 것을 말한다. 이것을 **Concurrency (동시성)** 라고 한다.


이때 동시성이 있는 두 루틴은 서로 의존 관계가 없다. 즉 커피를 마시지 않으면 신문을 읽을 수 없는 상황이 아니라는 의미이다. 동시성은 병렬성과 다르지만 동시성이 있어야 병렬성이 생기는데 서로 어느 것이 먼저 되어야하는 의존관계가 없어야한다. 예를 들어 양말을 신으면서 신발을 신을 수 없다. 양말을 신고 신발을 신어야한다. 즉 이 둘 사이(양말과 신발)에 동시성이 없으므로 병렬성도 없다.

### sync.WaitGroup()

따로 노는 고루틴들을 제어하기 위한 싱크 라이브러리가 있다. 파일 다운로드와 파일 압축하는 작업이 있다고 가정해보자. 파일 다운로드 후 파일을 압축해야한다. 즉 압축작업은 파일이 모두 다운로드가 완료될 떄 까지 기다려야하는데 이 떄 `sync.WaitGroup()` 을 이용하여 제어할 수 있다. 여기서 모든 고루틴들이 파일 시스템을 공유하기 때문에, 즉 모든 고루틴에서 파일에 접근했을때 같은 곳에 접근하기 것이기 때문에 가능하다. 마찬가지로 메모리를 서로 공유가 가능하다.

-----

## 채널
메모리 및 파일시스템을 공유하는 방법외에 **채널** 을 이용하여 서로 다른 고루틴 사이에 통신을 할 수 있다. 다음은 채널의 특징이다.

* 채널은 보낸 데이터를 받을 수 있는 파이프와 같은 형태라고 볼 수 있다.
* 기본 자료형으로 제공된다.
* first class citizen.
* 양방향, 단방향 채널이 있다.
* 양방향 채널을 단방향 채널로 변환해서 사용가능하다.
* 맵처럼 생성해야 사용가능하다.
* 채널들을 서로 복사하는 경우 동일한 채널을 가리키는 것이 된다.
* 채널은 그 자체로 포인터와 비슷한 레퍼런스형이라고 할 수 있다.


