# 비동기 프로그래밍

비동기 프로그래밍과 웹 프레임워크의 관계에 대해 알아보기전에 비동기 프로그래밍과 관련된 중요한 개념들인 Blocking I/O, Non-Blocking I/O, Parallelism(병렬성), Concurrency(동시성 or 병행성), Asynchronous Programming(비동기 프로그래밍)을 살펴보고 각 개념들이 대표하고 있는 문제 해결 방식이 풀고자 하는 문제가 무엇이며 해결 방식과 문제를 추상화하여 알아보자. 그 후 비동기 프로그래밍을 적용한 웹 프레임워크란 무엇인지, 어떤 면에서 이점이 있는지 알아보자.

## Synchronous, Asynchronous, Non-Blocking, Blocking

**Synchronous** 에서 Syn 은 together(함께)라는 의미이며 뒤에 chronous 는 time(시간)이라는 의미이다. 따라서 **함께 어떤 시간을 맞춘다** 라고 해석할 수 있으며 **Asynchronous** 는 그 반대인 **함께 시간을 맞추지 않는다** 라고 해석할 수 있다. 동기, 비동기를 이야기할때는 반드시 **2가지 이상**을 언급해야하며(무엇과 무엇이), 시간 개념이 있어야한다.

* 동기 : 어떤 시간을 맞춘다
* 비동기 : 어떤 시간을 안맞춘다

A 와 B가 시작시간 또는 종료시간이 일치하면 동기이다. 에를 들어 A 와 B 쓰레드가 동시에 작업을 시작하면 동기(ex. Java's `CycileBarrier`), 메소드 리턴시간(A)와 결과를 전달받는 시간(B)이 일치하면 동기이다. 그리고 A가 끝나는 시간과 B가 시작하는 시간이 같으면 동기이다. 예를 들어 자바의 `synchronized` 와 `BlockingQueue` 가 있다.

블록킹 / 넌블록킹은 동기 / 비동기와 관점이 다르다. 내가 직접 제어할 수 없는 대상을 상대하는 방법이다. "내가 제어하지 못하는 제3의 존재, 대상을 내가 어떤식으로 상대할 것인가" 이런 부분의 설명이 필요하다면 블록킹 / 넌 블록킹 이야기를 같이하면 된다. 따라서 대상이 다소 제한적이며 예를 들어 I/O, 멀티쓰레드 동기화를 이야기할 때 블록킹 / 넌블록킹을 이야기할 수 있다.

정리하자면, 어떤 메소드를 호출하여 무언가를 가져와야하는데 받아와야 하는 데이터의 소스 자체가 내가 통제하지 못하는 제3의 존재로 부터 input을 받는다, I/O가 일어난다, 이럴때 블록킹 / 넌블록킹을 이야기할 수 있다. 또는, 나 말고 다른 스레드가 존재해서 무엇인가 작업을 하다가 어느순간부터 그 스레드로 부터 결과를 확인 받거나 그 스레드가 종료하는 것을 확인하고 넘어가야 하는 상황, 이런 상황일때 블록킹 / 넌블록킹을 이야기하면 된다.

> Ref) [스프링캠프 2017 [Day1 A2] : Async & Spring](https://www.youtube.com/watch?v=HKlUvCv9hvA&t=1847s)


## Non-Blocking I/O, Blocking I/O

- **Non-Blocking I/O** : 프로그램이 외부와 데이터를 주고받을 떄, 외부에서 데이터를 처리하는 동안 가만히 기다리는 것.
- **Blocking I/O** : 프로그램이 외부와 데이터를 주고받을 떄, 외부에서 데이터를 처리하는 다른 일을 하며 기다리는 것.

Non-Blocking I/O 같은 경우 외부에서 필요한 작업을 하는 동안 프로그램은 다른 일을 할 수 있다. 따라서 개발자의 역량에 따라 프로그램의 자원을 효율적으로 사용할 수 있다. 다만, 프로그램과 외부 작업 사이에 데이터를 주고 받기위한 약속이 필요하고 이를 위한 추가 구현을 해야한다 (Blocking I/O 같은 경우는 외부 작업의 결과를 받기전까지 멈추어서 기다리 때문에 그 자리에서 바로 받음). 

이 때 결과를 가져오는 방식에 따라 두 분류로 나뉠 수 있다.

1. 주도적으로 가져오는 방식 (Non-Blocking I/O)
2. 수동적으로 받아오는 방식 (Aysnchronous I/O)

이렇게 나누더라도 본질은 여진히 입출력 결과를 수행하는 과정동안 일하기를 멈추지 않고 가다린다는 점이다. 

## Parallelism, Concurrency

* **Parallelism** : 작업을 처리하는 일꾼을 물리적으로 **여러개 두어 같은 작업을 동시에** 수행하는 것을 의미, 일꾼이 여러개여야만 성립하는 개념.
* **Concurrency** : 일꾼이 **여러가지 일을 번갈아 가며** 수행하는 것을 뜻함. 일꾼의 수와는 상관없이 오로지 일꾼이 일하는 방식과 연관.

동시성과 병렬성을 같이 확보하면 시너지 효과를 낼 수 있지만, 둘 사이의 의존성은 전혀 없다. **동시성**은 <u>자원을 효율적으로 사용하는 것이 목적</u>이고 **병렬성**은 <u>많은 자원을 투자해서 일의 처리량을 늘리는 것이 목적</u>이다. 

마찬가지로 동시성과 Non-Blocking I/O를 같이 사용하면 시너지 효과를 낼 수 있지만 둘 사이의 의존성은 전혀 없다 (다만, 동시성을 확보한 많은 시스템에서 Non-Blocking I/O를 이용하여 직업의 효율을 높이는 방식이 일반적인 사용법). 

* 논블록킹 I/O : 외부 입출력과 프로그램 사이의 작업을 어떻게 할 것인가를 대표하는 개념
* 동시성 : 일꾼이 일하는 방식을 대표하는 개념

동시성을 확보한 프로그램이 논블록킹 I/O를 중요한 요소로 사용할 수도 있고, 사용하지 않을 수도 있다. 일꾼이 하나더라고 모든 작업에 똑같이 1초씩 작업을 진행하면 동시성을 확보했다고 할 수 있다. **풀고자 하는 문제에 따라 알맞은 추상적 개념을 재료로 삼아 조립할 뿐이다.**

병렬성과 동시성은 웹 프레임워크에서 중요한 요소라고 할 수 있는데 비동기 프로그래밍 방식을 사용하기 이전의 웹 프레임워크에서는 병렬성만으로 성능을 확보하였지만 **비동기 프로그래밍 방식을 통해 동시성을 확보하기 시작한 이후부터는 일꾼을 늘리는 방식을 넘어서 일꾼들을 더 효율적으로 사용하는 방식을 사용하기 시작했다.**

정리하자면, **동시성과 병렬성 둘 사이 의존성은 전혀 없으며 마찬가지로 Non-Blocking I/O 와 동시성 둘 사이 의존성도 전혀 없다.**

## Asynchronous Programming

비동기 프로그래밍이란? **실행한 코드의 결과를 기다리지않고 별도의 채널에 결과 처리를 맡긴 후 다음 작업을 바로 진행하는 방식의 프로그래밍**을 뜻한다. 코드 실행 결과가 다음 코드 들에서 직접 연관이 없는 경우 실행의 결과를 기다릴 이유가 없기 때문에 자원을 더 효율적으로 사용할 여지가 생긴다.

비동기 프로그래밍에서는 크게 2가지 방식(콜백, 언어에서 지원하는 방식)으로 결과를 처리한다.

### Callback
함수를 값처럼 넘기는 First-class function 을 지원하는 언어에서 자연스럽게 사용할 수 있는 기법. 비동기 프로그래밍 방식으로 진행할 코드를 실행할 때 실행하는 시점에 결과를 처리해 줄 함수를 일꾼에게 같이 넘기며 이꾼은 작업 후 실제 결과를 실행 시점에 받은 함수를 통해 처리한다. 

### 언어에서 지원하는 방식
비동기로 실행한 코드의 결과를 언어에서 지원하는 방식으로 되돌려 받아 처리하는 방식. 코드를 비동기로 실행할 때 해당 코드의 실제 결과가 아닌 언어에서 지정하는 방식으로 결과를 **즉시** 되돌려 받는다. 언어적 방식을 통해 즉시 되돌려 받는 결과로는 **Future**, **Promise** 같은 객체 형태, Python's **Coroutine**과 같은 언어의 문법을 이용하는 형태, Go's Goroutine, 결과를 주고받을 별도의 채널을 사용하는 형태 등이 있다. **즉시 되돌려 받은 결과를 이용하여 각 방식에 알맞게 추후에 비동기로 실행한 코드의 실제 결과를 꺼내어 사용하는 형태**이다.

- 객체형태
실행 흐름을 프로그램으로 구현하여 마음껏 다룰 수 있기 때문에 높은 자유도가 있지만, 이를 위한 코드를 더 구현해야한다. 

- 언어의 문법을 이용한 형태
언어가 제공하는 제어문을 통해 비동기 프로그래밍의 실행 흐름을 언어의 실행 흐름으로 가져와 코드를 작성할 수 있지만 비동기 실행을 언어의 특정문법에 제한된다.

### Asynchronous Wait

비동기 프로그래밍으로 실행했던 작업의 결과를 다시 최초의 실행 흐름으로 되가져와 사용해야 하는 경우, Asynchronous Wait 는 기존의 실행 흐름에서 필요한 결과를 비동기 프로그래밍으로 실행한 작업에서 만들어낼 때까지 기다려 **두 작업간의 타이밍을 맞추는 역할**을 한다. 비동기 프로그래밍으로 실행한 작업과 원래 실행 흐름을 묶어주는 중요한 기법이다. 특히 절차 중심의 언어에서는 Asynchronous Wait 를 이용하여 실행 흐름을 제어하는 것은 자연스러운 방식이다. 

Asynchronous Wait 는 비동기 프로그래밍에서 중요한 핵심 요소이지만 몇 가지 단점이 있다.

1. Deadlock(교착 상태) 문제가 발생할 여지
2. **추상화의 수준을 절차 중심 프로그래밍 언어의 수준으로 낮추는 주된 요인**이며 이로 인해 실행 흐름 제어의 늪에 빠지게 될 수 있음
3. 비동기 프로그래밍의 기능을 절차 중심 프로그래밍이 가지는 추상화 수준에 맞추어 사용할 수 밖에 없게되는 문제
4. 사용자의 역량에 따라 자원을 효율적으로 사용할 수 있는 여지가 크게 달라짐

비동기 프로그래밍의 **추상화 수준을 높이는 계산 모델 또는 프로그래밍 모델을 사용**하면 실행 흐름을 직접 제어하는 일(절차 중심 프로그래밍 관점)에서 벗어날 수 있으며 deadlock 에 빠질 상황을 피할 수 있다. 

* Haskell, Scala, OCaml (함수 중심 프로그래밍 언어): 비동기 프로그래밍의 흐름 제어를 모나드(Monad)를 이용하여 함수를 엮어가는 방식으로 추상화 수준을 높여 사용.
* Reactive Programming : 프로그래밍의 관점을 절차 중심이 아니라 데이터의 흐름으로 바꾸어 실행 흐름을 데이터 흐름에 맞추어 따라가도록 하는 방식으로 추상화 수준을 높여 사용.

---

비동기 프로그래밍은 동시성, Non-Blocking I/O 와 매우 흡사해보이지만 **독립된 정의로 다루어야 한다**. 비동기 프로그래밍은 **"결과를 기다리지 않고 다음 코드를 실행하는 흐름"** 을 대표하는 개념이다. 이를 구현하기 위해 여러 일꾼을 사용하든 일꾼 하나에 작업 순서를 조절하여 사용하든 어떻게 구현할 지는 비동기 프로그래밍과 연관이 있을 수도 있지만 정의의 구성 요소라고 볼 수 없다. 

예를 들어 Event Loop 를 사용하여 병렬성을 확보하지 않고 오직 동시성만으로 비동기 프로그래밍을 제공하는 방식이 있으며 Callback 방식을 사용하여 동시성 없이 비동기 프로그래밍을 제공할 수도 있다. 이들은 **비동기 프로그래밍의 코드 진행을 구현하는 구현 방식들 중 하나일뿐 비동기 프로그래밍이 병렬성, 동시성, Non-Blocking I/O 에 종속된 개념은 아니다**.

## Asynchronous Programming and Web Framework

웹 프레임워크에서 비동기 프로그래밍은 **요청을 받아 이를 처리할 로직을 호출할 때 비동기 프로그래밍 방식을 사용하는 것**을 뜻한다. 웹 프레임워크의 핵심 기능은 요청과 처리 로직을 연결해 주는 것인데 웹 프레임워크에 비동기 프로그래밍 방식을 적용하였다는 것은 **요청과 처리 로직을 연결하는 과정에서 비동기 프로그래밍 방식을 사용한다는 것**을 뜻한다. 요청을 처리 로직에 맡겨두고 나서 결과를 별도의 채널을 통해 다루도록 넘긴 후 다른 처리를 해야 할 요청으로 넘어가는 일을 반복한다.

비동기 프로그래밍의 추상적인 실행 흐름을 실제로 수행해 줄 구현체로 **동시성**을 확보 한 구현체를 사용하면 2가지 관점에서 자원을 효율적으로 사용할 수 있다.

1. 동시성을 확보하는 것 자체로 자원을 효율적으로 사용할 여지가 있음
2. 요청과 처리 로직을 연결해주는 일과 처리 로직의 일을 분리하여 자원을 효율적으로 사용할 수 있음

> TODO

### Thread Pool

많은 언어에서 비동기 프로그래밍을 제공하기위해 그 구현체로 스레드풀을 사용한다. 즉, 동시성과 병렬성을 확보하여 작업을 효율적으로 수행하기 위한 기법이다. 

> Thread Pool 이란?
> 일꾼의 단위를 스레드로 두고 미리 만들어둔 스레드를 풀에서 필요할 때 하나씩 꺼내어 사용하고 일이 끝나면 다시 풀에 넣어 다른 일에 사용할 수 있는 상태로 두는 방식

