## 나머지 연산

`(A+B) % C = ((A%C) + (B%C)) % C`
- 주로 다이나믹 문제를 풀때 사용 (경우의 수를 구할 때 너무 큰 경우 사용)

```
A = q1C + r1
B = q2C + r2
A+B = (q1+q2)C + (r1+r2)
(A+B)%C = (r1+r2)%C
A%C = r1
B%C = r2
```

## 최대 공약수 (GCD)

두 수 a와 b의 최대공약수 g는 a와 b의 공통된 약수 중에서 가장 큰 정수이다.
최대공약수를 구하는 가장 쉬운 방법은 2부터 min(a,b)까지 모든 정수로 나누어 보는 방법
최대공약수가 1인 두 수를 서로소라고 한다.
~~~ cpp
int g = 1;
for (int i=2; i<=min(a,b); i++) {
     if ( a%i == 0 && b % i ==0) {
          g = i;
     }
}
~~~
위 코드의 시간복잡도는 O(N)

좀 더 빠른 방법은?? -> 유클리드 호제법 사용
a를 b로 나눈 나머지를 r이라고 했을 때 
`gcd(a,b) = gcd(b,r)`과 같다 (gcd(a,b) = gcd(b, a%b))
r이 0이면 그 떄 b가 최대 공약수이다.

> ex) gcd(24,16) = gcd(16,8) = gcd(8,0) 따라서 최대공약수는 8

재귀함수를 이용하여 유클리트 알고리즘을 구현할 수 있다.
~~~ cpp
int gcd(int a, int b) {
     if(b==0) {
          return a;
     } else {
          return gcd(b, a%b);
     }
}
~~~

비재귀로 풀때 다음과 같이 구현 가능.
~~~ cpp
int gcd(int a, int b) {
     while(b!=0) {
          int r = a%b;
          a = b;
          b = r;
     }
}
~~~

a가 b 보다 작을 때 swap을 해주어야 되지 않을까? -> 할 필요 없다.
a < b 일때 b는 a가 된다. a는 a%b = a 이기 때문에 그대로 a가 된되기 때문에 따로 대소관계를 비교하여 바꾸어줄 필요는 없다.

세 수의 최대공약수는?
`gcd(a,b,c) = gcd(gcd(a,b),c)`
이런식으로 n개의 수 최대공약수도 구할 수 있다.

# 최소공배수 (LCM)
두 수의 공통된 배수 중 가장 작은 수
최대공약수를 이용하여 구 할 수 있다.
L*G = A*B 이므로 L = (A*B)/G 하지만 A*B 에서 수의 범위가 넘어갈 수 있으므로 다음과 같이 계산하는게 좋다. L = G * (A/G) * (B/G)

# 진법 변환
10진법 수를 B진법으로 바꾸려면 N이 0이 될 때까지 나머지를 계속 구한다.
11/3 = 3 .. 2 
3/3 = 1 …  0
1 / 3 = 0 …1
따라서 11은 3진법으로 102이다.

B진법 수를 10진수로 바꾸려면  B^k을 곱하면서 더해가면 된다.
3진법 수 102 = 1 * 3^2 + 0 * 3^1 + 2 * 3^0 = 11

A진법을 B진법으로 바꾸려면 
A진법 -> 10진법 -> B진법 으로 구하면 된다.

# 소수
- 약수가 1과 자기 자신 밖에 없는 수
N이 소수가 되려면 2보다 크고  N/2보다 작거나 같은 자연수로 나누어 떨어지면 된다. -> 시간 복잡도는 O(N) 왜냐 N/2 에서 1/2는 상수이기 때문에 없는 것으로 처리.

그러면 제일 빠른 방법은??
루트 N까지만 나누어 떨어지면 된다.

소수가 아닌경우 N = a*b으로 나타낸다고 하자. 그러면
 a <= 루트N 또는 b <= 루트N (두 수중에 적어도 하나는 루트N 보다 작다)
만약 두수가 모두 루트N 보다 크면 a*b는 N이 될 수가 없기 때문이다.

만약 a <= b라고 가정하자. a가 될 수 있는 것은 2 ~ 루트N 이다. b도 약수인데 b는 a보다 큰 약수가 되기 때문에 2부터 루트N까지만 나누어 비교하면 된다. -> 시간복잡도 O(루트N)

ex) 24
루트24 = 4.x
2 3 4 | 6 8 12
만약 왼쪽에서 나누어 떨어지지 않았으면 오른쪽에서도 반드시 나누어 떨어지지 않는다.

에라토스테네스의 체
- 아직 지워지지 않은 수 중에서 가장 수의 배수를 모두 지운다.

~~~ cpp
for (int i=2; i<=n;i++) {
     if (c[i] == false) {
          p[pn++] = i;
          for(int j=i*i; j<=n; j+=i) {
               c[j] = true;
          }
     }
}
~~~
위 코드의 시간복잡도는 O(NlglgN) 

~~~ cpp
for(int j=i*i; j<=n; j+=i) {
     c[j] = true;
}
~~~
위 코드의 의 시간 복잡도는 `prime harmonic series` 으로 lglgN

i*i 때문에 수 범위가 초과 될 수 있다. 따라서 i+i 나 i*2로 쓴다.

## 골드바흐의 추측
2 보다 큰 모든 짝수는 두 소수의 합으로 표현 가능.