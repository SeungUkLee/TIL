# 스칼라란 어떤 언어인가?

## 코드의 작관성과 신축성
스칼라는 코드가 짧으면서 직관적이다. 자바에서 반복문, 생성자,  getter, setter 등 반복적이고 지루한 작업들을 스칼라에서는 몇 줄의 코드로 끝낼 수 있다. 

숫자 리스트 중 5 이상의 숫자만 골라내는 코드를 짠다고 하자. 스칼라를 이용하면 다음과 같이 간단하게 짤 수 있다.
`val otherList = list.filter(i => i>=5)`

## 풍부한 표현식과 연산자
스칼라는 풍부한 표현식 및 다양한 연산자를 가지고 있으며 익히는데 조금 시간이 걸려도 얻을 수 있는 효과는 크다고 할 수 있습니다. 

예를 들어 animal 이라는 객체와 그 안에 구현되어 있는 eat() 메서드를 이용해서 매개변수 fruit를 주고 싶다고 하자.

자바에서는 다음과 같이 표현합니다.
`animal.eat(fruit);`

스칼라는 다음과 같이 표현할 수 있습니다.
animal eat fruit
(자바와 똑같은 형식으로 쓰는 것도 가능하다.)

스칼라는 다양한 연산자가 존재하며 이 연산자들 모두 하나하나 메서드로 구현되어 있다.

예를 들어 List 에는 ++라는 연산자이자 메서드가 있다.
다음과 같이 두 개의 리스트를 붙일 때 사용된다.
`list1 ++ list2` (list1과 list2를 합친 결과)

## 동시성에 강한 언어
스칼라는 동시성 문제를 항상 염두에 두고 해결하는 방향으로 언어가 이루어져있다.
여러 프로그래밍 언어에는 스레드라는 것이 존재한다. 스레드를 사용하면 복잡하게 프로그래밍 될 위험이 있으며 오류가 일관성 없이 테스트할 때마다 다르게 튀어나오기 때문에 개발 및 유지보수의 어려움이 있습니다. 만약 한 객체에 여러 스레드가 접근한다면 그 객체의 상태가 정확히 어떠한 위치(어떠한 값으로 바뀔수도 있고 아닐수도 있고)에 있다고 말하기 어려워집니다. 동시에 숫자를 세는 단순한 프로그램 조차 실행할 때마다 순서가 다르기 때문에 그 순서가 어떻게 될지 알 수 없다. 

스칼라에서는 많은 부분이 변경불가능한(immutable) 속성을 가지게끔 되어 있는데 이를 통해 명확하게 나타내게 프로그래밍 할 수 있다. 이것은 기존의 함수형 프로그래밍으로부터 이러한 동시성 문제의 해결법에 대한 장점을 흡수한 것이라고 볼 수 있다. (뿐만 아니라 객체지향 프로그래밍의 유연함을 동시에 가지고 있다.)

스칼라는 동시성 프로그래밍에 뛰어난 라이브러리 Akka를 사용할 수 있다. Akka는 동시성 프로그래밍에서 뛰어난 액터 모델을 이용하고 있기 때문에 동시성 프로그래밍에 뛰어나다고 볼 수 있다. 
액터 모델이란?
각각의 액터가 서로 간의 메시지를 통해서만 의사 소통을 하고, 액터를 이루는 각종 변수나 속성을 서로 공유하지 않는다.


## 객체지향 + 함수형 언어
스칼라에서는 모든 것이 객체이다. 따라서 함수의 매개변수에 함수 객체를 집어넣을 수 있고, 변수에 함수를 할당 할 수도 있다. 
userId가 “admin”인 회원을 찾아 정보를 삭제한다고 하자. 
`Member.members.filter(_.userId === “admin”).delete`

## 맥락을 읽는 언어
스칼라는 프로그래밍의 맥락을 읽을 수 있는 똑똑한 친구이다. 스칼라는 필요할 때 implicit 예약어를 사용하여 명시적인 표현을 감춰버릴 수 있다.

때로 프로그래밍을 하다 보면 하나의 추가적인 데이터를 보내는 로직을 추가하기 위해 그와 관련된 모든 메서드의 매개변수나 반환 형태를 고쳐야하는 경우가 있다. 스칼라는 필요하다면 알아서 프로그램의 맥락을 읽어 필요한 곳에 필요한 것을 할당해 준다.

만약 한국어만을 사용하는 프로그램을 사용자의 국적에 따라 바꿔야하는 상황이라고 하자. 즉 사용자의 브라우저 언어 세팅을 읽어 메서드에 반환 자료형 등을 계속 보내주게끔 바꿔야 한다고 하자.
관련 메서드가 많으면 수많은 디버깅을 통해 고쳐야 할 곳이 많아 질 수도 있다. 만약 암묵적으로(implicit) 매개변수를 넣어줄 수 있으면 고쳐야 할 곳은 대폭 줄어들것이다. 실제로 스칼라는 그 언어 정보만 받는 곳만 iimplicit를 선언하여 컴파일러가 알아서 언어 정보 매개변수를 찾도록 구현할 수 있다.

## 자바와 뛰어난 연계성
스칼라는 자바와 호환이 된다. 자바의 라이브러리가 필요하면 언제든지 import하여 사용가능하다. 스칼라는 자바가 사용하는 JVM을 사용한다.

모든 것이 객체이며, object는 싱글턴 객체!
Hello World를 출력하는 코드(스칼라)
~~~ scala
object Test {
     def main(args: Array[String]): Unit = {
          println(“Hello World”)
     }
}
~~~

Hello World를 출력하는 코드(자바)
~~~ java
public class Test {
     public static void main(String[] args) {
          System.out.println(“Hello World”);
     }
}
~~~

클래스 선언으로 시작하는 자바와 다르게 스칼라는 객체 선언으로 시작됩니다. 스칼라에서 객체는 자바로 치면 static class 형식으로 new를 통해 인스턴스를 생성하는 것이 아닌 처음부터 단 하나의 인스턴스만 생성 가능한 싱글턴 객체이다. 

## 싱글턴 객체란?
여러 인스턴스를 생성하지 못하고 단 하나의 인스턴스만 생성가능하다.

결론적으로 스칼라는 자바처럼 static 예약어가 필요없다. 만약 static 기능이 필요하면? 스칼라에서 object 예약어는 클래스 자체를 싱글턴 객체로 만들기 때문에 object 안에 구현하고 바로 가져다 쓰면 된다.
다시말하지만 스칼라에서는 모든 것이 객체!. + 와 같은 연산도 함수형태를 가지는 객체!(함수도 객체)

## 함수가 다르다!
함수는 def로 정의할 수 있다. 접근제어자 없다. Hello World를 출력하는 스칼라 코드를 보면 Unit을 반환하고 있는데 Unit은 자바의 void와 동일하다고 생각하자.(즉, 아무것도 반환하지 않는다라는 사실을 명시적으로 표현 해주는 것) 이러한 함수 자체도 function이라는 객체를 내부적으로 이용하는 하나의 객체이다. 필요한 경우 변수에 담을 수 있으며 변수처럼 행동할 수 있다.   




