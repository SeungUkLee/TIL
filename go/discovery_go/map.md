# Map

## Map 특징

Go 언에서 map은 hashtable(해시테이블)로 구현되었다. key(키) 와 value(값)으로 되어 있으며 키를 이용하여 값을 상수 시간에 가져올 수 있다. 대신 순서가 없다. 


## Map 변수 정의

다음과 같이 맵을 담는 변수를 정의할 수 있다.
~~~ go
var m map[keyType]valueType
~~~

맵을 담을 수 있지만 맵이 생성되어 있지는 않기 떄문에 이 상태로는 맵을 이용할 수 없다. 즉 빈 맵으로 취급하여 맵을 읽을 수 있지만 변경이 불가능하다는 말이다.
nil 값을 가지고 있는 slice(슬라이스)에 `append()` 를 이용하여 값을 추가할 수 있지만 맵은 일단 생성이 되어 있어야 추가할 수 있다. 

## 빈 Map 초기화

`make()` 를 이용하거나 `{ }`를 이용하여 빈 맵으로 초기화할 수 있다.

~~~ go
m := make(map[keyType]valueType)

m2 := map[keyType]valueType{}
~~~

## Map 값 읽기
맵에서 읽을 때는 2가지 방법이 있다. `m[key]` 를 이용하여 맵의 value(값)을 읽을 수 있고 해당 키가 없으면 값의 자료형의 기본값을 반환한다(값의 자료형이 정수이면 0, 문자열이면 빈 문자열). 다음과 같이 2개의 변수를 이용하여 키가 존재하는지 여부를 bool형으로 받을 수 있다.

~~~ go
value, ok := m[key]
~~~

## Map 값 쓰기

맵에 이미 키가 들어 있는 경우에는 기존에 있던 값이 변겨오디고 없는 경우에는 새로 생긴다.

~~~ go
map[key] = value
~~~

## Map 활용하기

밑의 코드는 문자열 안에 있는 각 문자를 세는 함수이다. 이 함수는 이미 생성되어 있는 맵을 받아 각 문자가 몇번 출현하는지 세어준다.

~~~ go
fucn count(s string, codeCount map[rune]int) {
    for _, r := range s {
		codeCount[r]++
	}
}
~~~

슬라이스와 다른 점은 맵을 이용할 때에는 맵 변수 자체에 다시 할당하지 않으므로 포인터를 취하지 않아도 맵을 변경할 수 있다. 반면에 슬라이스는 추가할 때 `a = append(a, 1)` 와 같은 형식이 사용되어 포인터를 넘겨야 추가할 수 있다.

## Map 테스트하기

맵은 순서가 없기 때문에 맵에 들어가 있는 값들을 꺼낼 때, 어느 값이 먼저 나올지 알 수 없다. 물론 맵의 키 값에 순서가 있고, 그에 대한 해시값에도 순서가 있지만 해시 함수가 바뀔 수 있기 때문에 해시값의 순서에 의존적인 코드나 테스트를 작성하면 안된다. `==`로 맵 끼리 비교한다고 해서 내용을 비교해주지도 않으며 `fmt.Println`으로 출력하더라고 매번 순서가 다르게 출력되기 때문에 테스트하는게 어려움이 있다. 

### reflect.DeppEqual 을 이용한 테스트

가장 간단하게 `reflect.DeppEqual` 을 이용하는 방법이 있다.



