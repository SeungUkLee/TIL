# GraphQL

> NOTE: GraphQL을 간편하게 gql 이라고 표현

**GraphQL** : 웹 클라이언트가 데이터를 서버로 부터 효율적으로 가져오는 것이 목적
**SQL** : DB 시스템에 저장된 데이터를 효율적으로 가져오는 것이 목적

서버사이드 gql 어플리케이션은 gql로 작성된 query를 받아 query를 처리한 결과를 다시 클라이언트로 돌려준다. gql은 네트워크 방식에 종속되지 않는데 gql의 인퍼테이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메소드와 웹소켓 프로토콜을 활용한다. 필요에 따라 얼마든지 L4의 TCP/UDP를 활용할 수 있다. 또는 L2 형식의 이더넷 프레임을 활용할 수도 있다.

## REST API vs GraphQL

* **REST API**
    - 다양한 엔드포인트가 존재
    - 각 엔드포인트마다 DB SQL 쿼리가 달라진다
    - 여러번 호출해야한다 (ex. `/posts`, `/comments`, `/authros`)

* **GraphQL**
    - 단 하나의 엔드포인트가 존재
    - GQL 스키마의 타입마다 DB SQL 쿼리가 달리진다
    - 여러번 호출할 필요없이 한번의 호출로 처리 가능 (ex. `/graphql`)

## GraphQL의 구조

### Query / Mutation (쿼리 / 뮤테이션)

쿼리는 데이터를 읽는데 사용 (Read), 뮤테이션은 데이터를 변조하는데 사용 (Create / Update / Delete) 할 때 사용한다는 개념적인 규약을 정해놓았지 사실 둘은 별 차이 없다.

gql을 사용하면 벡앤드와 프론트엔드의 협업 방식이 이전 방식(REST API)과 차이점이 생긴다

* REST API
    - 프론트엔드 개발자는 백엔드 개발자가 작성하여 전달하는 API의 request / response 형식에 의존하게 됨

* GraphQL
    - 위의 의존도가 많이 사라짐
    - 하지만 데이터 schema에 대한 협업 의존성은 존재함

### Schema / Type (스키마 / 타입)

```graphql
type Student {
    name: String!
    class: [Class]!
}
```

- 오브젝트 타입 : `Student`
- 필드 : `name`, `class`
- 스칼라 타입 : `String`, `Id`, `Int` 등
- ! : 필수 값을 의미
- [] : 배열

### Resolver (리졸버)

gql 쿼리문 파싱은 gql 라이브러리에서 대부분 처리하지만 gql에서 데이터를 가져오는 구체적인 과정은 리졸버가 담당하며 이를 직접 구현해야한다. 직접 구현해야하는 부담이 있지만 데이터 종류에 상관없이 구현이 가능하다. 예를 들어 리졸버를 통해 데이터를 DB, file 뿐만아니라 http 와 같은 네트워크 프로토콜을 활용하여 원격 데이터를 가져올 수 있다.

gql 쿼리에는 각 필드마다 함수가 하나씩 존재하는데 이 함수는 다음 타입을 반환한다. 이러한 각각의 함수를 리졸버라고 부른다. 만약 필드가 문자열이나 숫자 같은 primitive 타입 즉, 스칼라 값인 경우에는 더 이상 연쇄적인 리졸버 호출이 일어나지 않고 실행이 종료된다. 반대로 우리가 정의한 타입이면 해당 타입의 리졸버를 호출한다.

이러한 연쇄 리졸버 호출을 잘 활용하면 DBMS의 관계에 대한 쿼리를 쉽고 효율적으로 처리할 수 있다.

## GraphQL와 비즈니스 로직

비지니스 로직은 실제 리졸버 함수에 담지 않는다. 로직은 비지니스 로직 레이어에 작성을 하는 것이 좋다. (이는 REST API를 제작할 때 사용하는 패턴과 동일)

## Reference

[GraphQL 개념잡기](https://tech.kakao.com/2019/08/01/graphql-basic/)
