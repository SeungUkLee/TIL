OS 상에서 sleep 과 lock 함수 처리과정을 알아보자.

 
**1. lock**

- lock 은 커널의 동기화(synchronization)에서 공유자원에 동시 접근하는 것을 막는 개념
- lock 은 아키텍쳐에 의존적이고 대부분 어셈블리로 구현
- 아키텍쳐에서 data bus lock 을 지원하는 경우도 있고 spin-lock 과 같이 CPU 클럭을 소모하면서 busy-wating 하는 경우도 있음
- lock 은 CPU가 쿨럭을 소비하면서 대기하고 있는 특징이 있음

**2. sleep**

- sleep 은 커널의 프로세스 스케쥴링에 관련되는 개념
- sleep 은 busy-waiting 하지 않고, 현재 CPU에 실행되고 있었던 IP(Program Counter), 각종 레지스터값 및 스택등의 정보를 메모리에 보관 **(context switching)**
- 즉, 현재 CPU에서 실행되고 있는 프로세스를 메모리로 sleep 시키는 것
- 이렇게 하면 CPU는 다른 읽을 할 수 있음
- sleep 하는 시간 및 관리는 커널안의 타이머 인터럽트와 프로세스 스케쥴러가 함
- context switching 으로 인해 CPU에게 부하를 줄 수 있는 단점이 있어서 인터럽트에서는 사용하지 않는 특징있음


프로세스가 sleep() 을 호출하면 그에 대응하는 시스템 호출(system call)이 이루지고 커널 모드로 진입해서 그 시스템 호출 핸들러를 실행한다. 핸들러에서는 타이머용 대기 큐에 그 프로세스를 넣어두면서 "이 프로세스틑 몇 초후에 일어나야됨" 표시도 해둔다. 실행하던 프로세스를 대기 큐에 넣어서 할 일 없으면 스케쥴러를 실행한다. 다음 프로세스를 실행하고, 실행할 프로세스가 없으면 그냥 논다(idle 테스크를 실행).

시스템에서는 주기적으로 타이머 인터럽트가 발생하는데 하드웨어 쿨럭에서 인터럽트를 발생시키고, 그떄 마다 운영체제의 인터럽트 핸들러를 실행한다.

타이머 인터럽트 핸들러에서 수행하는 작업들 중 하나가 타이머 대기 큐를 확인하는 것이다. 충분한 시간이 지나 큐의 맨 앞에 있는 프로세스를 깨워야할 시점이 되면 그 프로세스를 깨운다. (대기큐에서 준비큐로 옮긴다). 인터럽트 핸들러 실행이 끝난 직후 다시 스케쥴러를 실행하고 그 떄 (우선순위 높은 다른 프로세스가 없다면) 방금 준비 큐에 넣은 프로세스를 실행한다.

sleep 하는 프로세스 말고 다른 프로세스들은 무시한다면, sleep 으로 대기하는 동안의 CPU 활동은 주기적인 타이머 인터럽트 핸들러 실행이 전부이다. 이에 사용되는 CPU 시간은 적어 CPU 점유율 통계에는 잡히지 않는다.

세마포어 같은 sleep 가능한 락의 경우도 유사한다. 타이머 대기 큐 대신 세마포어에 딸린 대기 큐에 프로세스를 넣으며, 타이머 인터럽트 핸들러에서 프로세스를 꺠우는 것이 아니라 다른 프로세스가 세모포어를 up 할 떄의 시스템 호출 핸들러에서 프로세스를 깨운다 정도의 차이이다.

실제 OS 구현에서는 몇 가지 변형이 추가되기도 하지만 기본 구조는 이렇다.

## Reference

[sleep() 함수의 원리에 관하여](https://kldp.org/node/125415)
