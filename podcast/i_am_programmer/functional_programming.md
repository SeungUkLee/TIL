# 나는 프로그래머다 - 함수형 프로그래머를 찾아서

## 1부

[24:40 ~ ]
스칼라를 FP 쪽으로 사용하려고 하다보면은 하스켈보다 표현하기 어려운 부분이 생긴다(개념적인 부분도). 예를 들어서 하스켈의 Algebra Data Type 에 대응하는 것이 스칼라에서는 sealed trait 과 case class 이다. 차이점은 하스켈로 보자면 타입 노출은 trait 만 되고 case class 는 타입이 아니라 데이터이기 때문에 외부에 타입으로 노출이 안된다.


[31:55 ~ ]
Natural transformation -> morphism of functors
쉽게 말하자면 데이터를 바꾸는 것이 아니라 데이터 밖 펑터를 바꾸는 것, 껍데기를 바꿈

## 2부

함수형 프로그래밍의 장, 단점

함수형 언어 프로그래밍 패러다임이 다른 패러다임과 다른점이 추상화를 어디까지 시도하느냐 부분 같다. 굉장히 작은 패턴까지도 추상화 시키고 그 추상화 속에서도 패턴을 찾아서 또 추상화시키고... A라는 문제를 그냥 풀 수 있는데 "A 속에서는 먼가 다른 개념이 녹아있네? 그 개념을 뽑아내서 A는 그 다른 개념의 하나의 special case 구나!" 하고 발견하고 공부하는 것이 굉장히 재밌다. 이런 추상화들에 익숙해지게 되면 몇 개 안되는 추상화들이 여러 문제를 해결하는데 도움을 줄 수 있고 이 부분에서는 생산성에 굉장히 큰 도움을 줄 수 있다. 어떤 문제들이 한번 추상화 시켰더니 "이거는 A구나, 이거는 B구나" 이렇게 되면 이 솔루션들을 바로 적용시킬 수 있기 때문이다.

하지만, 생산성이 마이너스 되는 부분은 당장 풀어야될 A라는 문제가 있는데 "이거는 어떻게 더 추상화 할 수 있지? 아! 이렇게 추상화 될 수 있고 저렇게도 되네.." 이렇게 고민을 많이 하게되고 문제는 점점 산으로 가는 경우가 발생한다. 

스칼라 같은 경우도 똑같은 문제로 굉장히 많은 풀이가 나오는데 선택지가 많다는 것은 생산성의 마이너스 요인이라고 생각한다. 

[3:30 ~]
또 다른 장점으로는 추상화를 연습하는데 큰 도움이 되는 것 같다.

처음에는 오버엔지니어링일 수 있는데 특정 임계점이 넘어가는 순간 코드양이 많이 줄어드는 모습을 볼 수 있다.

[5:35 ~]
어떤 하나의 개념을 배울 때 한번씩 오버를 해봐야되는 것 같다. 그래야지 다시 step back 할 수 있다. "나는 여기까지 써볼래" 하면 그 기술이 어디까지 가는지 경험을 못해보기 때문에 한계를 정해두는 것 보다는 오버 해보면서 생각해보는 것도 좋을 것 같다.

[6:20 ~]
OOP polymorphism 을 통해 해결하려고 했는데 FP의 Free Monad 와 비슷한 개념으로 해결을 해보았다.

[7:50 ~]
Free 모나드, Freer 모나드

[10:50 ~]
Haxl

[15:00 ~]
개미수열

[23:50 ~]
코루틴이 어찌보면 개미수열 문제의 핵심인 것 같다.

Lazy evaluation은 코루틴을 구현하는 또 다른 하나의 수단(모양)으로 볼 수 있었다. 

제너레이터는 일종의 코루틴이다.

Lazy evaluation 이 적용된 Lazy stream 의 동작방식이 사실은 코루틴의 동작방식과 굉장히 비슷하다.

[26:30 ~]
그러면 코루틴은 참조 투명성을 보장해야 가능한 것인가? 없어도 상관없는 것인가? 
코루틴 자체는 런타임이 지원해야되는 부분이라서 상관없다.

## 3부



## 4부



## 5부 (마지막)
