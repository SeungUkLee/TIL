# 자바스크립트 객체

객체 : 이름과 값이 있는 속성들을 포함하는 컨테이너. (속성의 값은 undefined를 제외한 모든 값이 사용될 수 있다.)

자바스크립트에서 단순한 데이터 타입으로 숫자, 문자열, 불리언, null, undefined가 있다. 이들을 제외한 다른 값들은 모두 객체이다.
숫자, 문자열, 불리언은 메소드가 있기 때문에 유사 객체라고 할 수 있지만 값이 한번 정해지면 변경할 수 없다.(immutable)
자바스크립트의 객체는 변형 가능한 속성들의 집합이라고 할 수 있으며 (배열, 함수, 정규 표현식 모두 객체) 클래스가 필요없다. (free class)
객체 하나에 있는 속성들을 다른 객체에 상속하게 해주는 프로토타입(prototype) 연결 특성이 있다.

## 1.객체 리터럴
객체 리터럴은 새로운 객체를 생성할 때 매우 편리한 표기법으로 아무 것도 없거나 하나 이상의 이름/값 쌍들을 둘러싸는 중괄호이다.

```js
var empty_object = {}
var stooge = {
    "first-name": "seunguk",
    "last-name": "lee",
}

var flight = {
    airline: "Oceanic",
    number: 815,
    departure: {
        IATA: "LAX",
        time: "2013-12-13"
        city: "LA",
    },
}
```

## 2.속성값 읽기
객체에 속한 속성의 값은 속성 이름을 대괄호로 둘러싼 형태로 읽을 수 있으며 속성 이름이 유효한 이름이고 예약어가 아닐 경우 마침표 표기법을 대신 사용 가능.
마침표 표기법을 더 선호.

```js
stooge["first-name"]  // "seunguk"
flight.departure.IATA // "SYD"
```
객체에 존재하지 않는 속성을 읽을려고 하면 undefinedf를 반환.
|| 연산자를 사용하여 기본값을 지정할 수 있다.


## 3.속성값 갱신
만약 할당하는 표현식에서 속성 이름이 이미 객체안에 존재하면 해당 속성의 값만 교체한다.
객체 내에 존재하니 않는 경우에는 해당 속성을 객체에 추가한다.

## 4.참조
객체는 복사되지 않고 참조 방식으로 전달된다.

## 5.프로토타입
모든 객체는 속성을 상속하는 프로토타입 객체에 연결되어 있다.
객체 리터럴로 생성되는 모든 객체는 자바스크립트 표준 객체인 Object의 속성인 prototype(Object.prototype) 객체에 연결된다.

객체를 생성할 때 해당 객체의 프로토타입이 될 객체를 선택할 수 있다.

Object 객체에 create 라는 메소드를 추가해보자. create는 넘겨받는 객체를 프로토타입으로 하는 새로운 객체를 생성하는 메소드이다.

```js
if (typeof Object.create !== 'function') {
    Object.create = function (o) {
        var F = function () {}
        F.prototype = o
        return new F()
    }
}

var another_stooge = Object.create(stooge)
```

프로토타입 연결은 값의 갱신에 영향을 받지 않는다. 즉 객체를 변경하더라도 객체의 프로토타입에는 영향을 미치지 않는다.

```js
another_stooge['first-name'] = 'harry'
another_stooge['middle-name'] = 'moses'
another_stooge.nickname = 'Moe'
```

프로토타입 연결은 오로지 객체의 속성을 읽을 떄만 사용한다.
객체에 있는 특정 속성의 값을 읽으려고 하는데 해당 속성이 객체에 없는 경우 자바스크립트는 이 속성을 프로토타입 객체에서 찾으려고 한다. 이러한 시도는 프로토타입 체인의 가장 마지막에 있는 Object.prototype까지 계속해서 이어지며 어디에도 존재하지 않는 경우 undefined 를 반환한다. 이러한 일련의 내부 동작은 delegation(위임)이라고 한다.

프로토타입 관계는 동적 관계이다. 만약 프로토타입에 새로운 속성이 추가되면 해당 프로토타입을 근간으로하는 객체들에는 즉각적으로 이 속성이 나타난다.
```js
stooge.profession
another_stooge.profession
```
예제로 나오는 stooge , another_stooge로 프로토타입 개념을 설명하면 다음과 같다.
another_stooge의 프로토타입은 stooge이며 stooge는 another_stooge의 프로토타입 객체가 된다. 그리고 another_stooge가 자신의 프로토타입인 stooge에 연결되어 있으며 stooge는 다른 객체에 연결되어 있는 식으로 특정 객체의 프로토타입 견결 전체를 프로토타입 체인으로 보면 된다.

## 6.리플렉션(reflection)

객체에 어떤 속성들이 있는지는 특정 속성을 접근해서 반환하는 값을 보면 쉽게 할 수 있는데 이때 typeof 연산자는 속성의 타입을 살펴보는데 유용하다.
하지만 해당 객체의 속성이 아니라 프로토타입 체인 상에 있는 속성을 반환할 수 있기 때문에 주의해야한다.

리플렉션을 할 때 원하지 않는 속성을 배제하기 위한 2가지 방법이 있다.

1. 함수값을 배제하는 방법 - 리플렉션을 할 떄는 데이터에 관심을 가지는 경우이기 때문에 함수가 반환되는 경우를 염두에 두고 배제시키면 원하지 않는 속성을 배제할 수 있다.

2. 객체에 특정 속성이 있는지를 확인하여 true/false를 반환하는 hasOwnProperty 메소드 사용. - hasOwnProperty 메소드는 프로토타입 체인을 바라보지 않는다.

## 7. 열거
for in 구문을 사용하면 객체에 있는 모든 속성의 이름을 열거할 수 있다. 이때 함수나 프로토타입에 잇는 속성 등 모든 속성이 포함되기 때문에 필터링 할 필요가 있다. 필터링 방법은 hasOwnProperty 메소드와 함수를 베제하기 위한 typeof를 사용하는 것이다.

## 8.삭제
delete 연산자로 객체의 속성을 삭제할 수 있다. delete 연산자는 해당 속성이 객체에 있을 경우에 삭제를 하며 프로토타입 연결 상에 잇는 객체들은 접근하지 않는다.

## 9.최소한의 전역변수 사용
전역변수는 가능하면 피하는 것이 좋다. 만약 애플리케이션에서 전역변수를 사용해야 될 경우에는 다음과 같이 전역변수를 하나를 만들어 이 변수를 다른 전역 변수를 위한 컨테이너로 사용하는 것이다.

```js
var MYAPP = {}

MYAPP.stooge = {
    "first-name": "seunguk",
    "last-name": "lee",
}

MYAPP.filght = {
    airline: "Oceanic"
}
```
이런식으로 필요한 전역변수를 이름 하나로 관리하면 다른 애플리케이션이나 라이브러리들과 연동할 때 발생하는 문제점을 최소화할 수 있다. 클로저를 사용하면 전역변수 사용을 줄일 수 있다.